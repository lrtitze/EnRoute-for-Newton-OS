func(err)	begin	local funcSMungeAppend := k_SMungeAppendFunc;	local funcStrMungeCRLF := k_StrMungeCRLFFunc;	if instructedToCancel then		begin		v_SMTP_state := kState_smtpHello;		AddDelayedSend ( self, 'SM_SMTP, [ k_EmptyString ], 1 );		return;		end;	if not err then		begin		//if kDebugOn then		//	begin		//	try :SetInputSpec ( is.SMTP );		//	onexception |evt.ex| do nil;		//	end;		// LRT - 97/06/04 2:37 AM		// NOT REQUIRED HERE:		//local doQuote := transport:GetConfig ( 'txQuotedPrintable );		// LRT - 97/01/24 10:58 PM		// new state for transmission		if v_SMTP_state = kState_smtpData_Txt then			begin			v_SMTP_state := kState_smtpData_Hdr;			self.resends := 0;			AddDelayedSend ( self, 'TxAsync, [ k_smtpBodyOutSpec ], 1 );			end;		else if v_SMTP_state = kState_smtpData_Hdr then			begin			GC();			// Main RFC822 headers have been sent			if v_curEncOff = -1 then				begin				if kDebugOn then print ( " - done wrapped body" );				// all done sending wrapped body text				v_SMTP_state := kState_smtpData_TxtDn;				// LRT - 97/01/24 10:26 PM				// no real need to send this extra <CR>				/******************************************				v_outStrBuff := Clone ( k_EmptyString );				call funcStrMungeCRLF with ( v_outStrBuff );				:TxAsync ( k_smtpBodyOutSpec );				******************************************/				AddDelayedSend ( self, 'SM_SMTPBody,					[ nil ], 1 );				return;				end;			// repeatedly called portion for body text Tx			v_outStrBuff := Clone ( k_EmptyString );			local thisSelf := self;			local txCBFunc := func ( outD, newOff )				begin				v_curEncOff := newOff;				if not v_doQuotedPrn then					begin					local words := SplitString(outD);					if Length ( words ) > 0					and StrFilled ( words[0] )					and BeginsWith ( words[0], "From:" ) then						begin						local a := Clone(words[0]);						StrMunger ( a, StrLen(a)-1, 0, " ", 0, nil );						StrReplace ( outD, words[0], a, 1 );						end;					end;				StrMunger ( v_outStrBuff, StrLen(v_outStrBuff), 0, outD, 0, StrLen(outD) );				if StrLen ( v_outStrBuff ) > 410 or newOff = -1 then					begin					local er := GetRoot().(kAppSymbol).enRoute;					v_SMTP_state := kState_smtpData_Txt;					AddDelayedSend ( er, 'SM_SMTPBody, [ nil ], 1 );					nil;	// stop uuEncoding for now					end;				else					true;	// continue uuEncoding				end;			local bin := MakeBinary ( 512, 'binary );			verrichten := kWrapTxAsyncFunc;			AddDelayedSend ( self, 'verrichten,				[ currentItem.bodyText, bin, v_curEncOff, 76, txCBFunc, v_doQuotedPrn ], 1 );			return;			end;		else if v_SMTP_state = kState_smtpData_TxtDn then			begin			// Body Text has been sent			// check to see whether enclosure will be sent			if kDebugOn then print ( " - done WrapTx" );			if not currentItem.encFrame then				begin				v_SMTP_state := kState_smtpData_BodyDn;				AddDelayedSend ( self, 'SM_SMTPBody, [ nil ], 1 );				return;				end;			if kDebugOn then print ( "Classof(currentItem.encFrame) =" && Classof(currentItem.encFrame) );			// LRT - 97/09/05 12:59 AM			// Adding handling for body class 'enRouteMIME			// which has 'data slot rather than 'bindata			// NEW:			if ClassOf ( currentItem.encFrame ) = 'enRouteMIME then				begin				// init vars for enclosure Tx in next state				v_curEnc    := currentItem.encFrame.data;				v_curEncSz  := Length ( v_curEnc );				v_curEncOff := 0;				// add 2 <CR><LF> pairs and a boundary marker to begin this part				header := Clone ( k_EmptyString );				call funcStrMungeCRLF with ( header );				call funcStrMungeCRLF with ( header );				call funcSMungeAppend with ( header, "--" );				call funcSMungeAppend with ( header, currentItem.boundary );				call funcStrMungeCRLF with ( header );				// fix CR -> CRLFs of application's headers				local appHdr := Clone ( currentItem.encFrame.headers );				if not StrPos ( appHdr, k_CRLF, 0 ) then					StrReplace ( appHdr, "\u000d\u", k_CRLF, nil );				call funcSMungeAppend with ( header, appHdr );				appHdr := nil;				// finish header with 2 blank lines				call funcStrMungeCRLF with ( header );				call funcStrMungeCRLF with ( header );				end;			// ORIGINAL:  (for uuencoding only)			else				begin				// init vars for enclosure Tx in next state				v_curEnc    := currentItem.encFrame.binData;				v_curEncSz  := Length ( v_curEnc );				v_curEncOff := 0;				// create the MIME header				verrichten := k_EncMakeHeaderFunc;				header := :verrichten ( currentItem );				end;			v_SMTP_state := kState_smtpData_EncHdr;			v_outStrBuff := header;			self.resends := 0;			:TxAsync ( k_smtpBodyOutSpec );			return;			end;		else if v_SMTP_state = kState_smtpData_EncHdr then			begin			if v_curEncOff = -1 then				begin				if kDebugOn then print ( " - done encoded enclosure" );				// all done sending uuEncoded data				// LRT - 97/09/05 12:59 AM				// Adding handling for body class 'enRouteMIME				// WAS:				//v_outStrBuff := Clone ( "end" );				// NEW:				v_outStrBuff := Clone (				if currentItem.encFrame.binData				or currentItem.encFrame.encoding = 'uuencode then					"end"				else					k_EmptyString );				call funcStrMungeCRLF with ( v_outStrBuff );				call funcStrMungeCRLF with ( v_outStrBuff );				local twoHyph := "--";				call funcStrMungeCRLF with ( v_outStrBuff );				call funcSMungeAppend with ( v_outStrBuff, twoHyph );				call funcSMungeAppend with ( v_outStrBuff, currentItem.boundary );				call funcSMungeAppend with ( v_outStrBuff, twoHyph );				call funcStrMungeCRLF with ( v_outStrBuff );				// LRT - 97/09/05 3:19 AM				// free up some much-needed space now!				RemoveSlot ( currentItem, 'encFrame );				v_SMTP_state := kState_smtpData_BodyDn;				self.resends := 0;				:TxAsync ( k_smtpBodyOutSpec );				return;				end;			// repeatedly called portion for encoded Tx			v_outStrBuff := Clone ( k_EmptyString );			local thisSelf := self;			local txCBFunc := func ( outD, newOff )				begin				v_curEncOff := newOff;				call funcSMungeAppend with ( v_outStrBuff, outD );				if StrLen ( v_outStrBuff ) > 410 or newOff = -1 then					begin					self.resends := 0;					AddDelayedSend ( thisSelf, 'TxAsync, [ k_smtpBodyOutSpec ], 50 );					nil;	// stop uuEncoding for now					end;				else					true;	// continue uuEncoding				end;			// LRT - 97/09/05 12:59 AM			// Adding handling for body class 'enRouteMIME			// WAS:			//verrichten := kUUEncodeAsyncTx;			// NEW:			verrichten := if currentItem.encFrame.encoding = 'base64 then				kBase64AsyncTx;			else				kUUEncodeAsyncTx;			AddDelayedSend ( self, 'verrichten,				[ v_curEnc, v_curEncSz, v_curEncOff, txCBFunc ], 1 );			return;			end;		else if v_SMTP_state = kState_smtpData_BodyDn then			begin			v_SMTP_state := kState_smtpMsgBody;			// end the SMTP body text			v_outStrBuff := " \u000D000A\u.\u000D000A";	// k_CRLF & "." & k_CRLF;			try :SetInputSpec ( is.SMTP );			onexception |evt.ex| do print ( "oops <2>" );			local compScr := func ( ep, opts, result )				begin				if kDebugOn then print ( " - <CRLF>dot<CRLF> is done!" );				if result then					begin					if kDebugOn then print ( " - ERROR:" && result );					AddDelayedSend ( ep, 'SM_SMTPBody,						[ result ], 50 );					end;				end;			local opFrame := {				async: true,				// LRT - 97/06/04 9:25 PM				// let's see what help we can provide by giving				// a requested timeout value of about 10 seconds				reqTimeout:	k_smtpDotCRTimeout,				form:	'string,				completionScript: compScr,				};			:TxAsync ( opFrame );			return;			end;		else			begin			if kDebugOn then				begin				write ( " - unexpected v_SMTP_state = " );				print ( v_SMTP_state );				end;			end;		end;	else		begin		// error occurred during TX		if err = -16005 or err = -36003 or err = -10039 then			begin			// LRT - 96/12/20 11:57 PM			:MNotify ( k_UnableToProceedPrefix			 & ParamStr ( LocObj ( "Rather than responding as expected, the ^0 server disconnected.", 'errors.serverDisconn ),			 	[ "SMTP" ] ) );			end;		else			begin			// LRT - 97/01/23 11:48 PM			:MNotifyError ( err );			end;		AddDelayedSend ( self, 'Link_Teardown, [], 1 );		try EntryUndoChanges ( currentItem );		onexception |evt.ex| do nil;		end;	end