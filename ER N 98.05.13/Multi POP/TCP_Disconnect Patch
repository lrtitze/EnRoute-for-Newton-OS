func native ()	begin	// NOTE: When called, SELF is the endpoint for	//       execution of the "TCP_Disconnect" function.	local switchAccounts;	local ownersA;	local popInfo;	if enRoute and _v_TCPEpState = 1	and not instructedToCancel and _v_LinkAcquired	and :GetConfig ( 'useMultiPOP )	and (ownersA := :GetConfig ( 'multiPOPAccounts ) )	and Length ( ownersA ) > 0 then		begin		if not enRoute.transport._v_multiPOPCtr then			begin			// this is the first time			enRoute.transport.(EnsureInternal('_v_multiPOPCtr)) := 0;			enRoute.(EnsureInternal('v_originalPersona)) := userConfiguration.currentPersona;			end;		// We'd have been unbinding an endpoint either because a		// 'Sending session had just completed and the user		// wanted sends after receives, or because a 'Receive		// session had just completed.		if direction = 'Sending and fDoRead then			begin			// CASE 1:  the send session completed and we're			// going to do the first receive.			// I think that in this case, we could leave the			// current logic to operate as it does.			end;		else if direction = 'Receiving then			begin			// CASE 2:  a receive session has completed			//	a) the POP session was the first receive			//	   session for "currentPersona"			//	b) we caused the receive session to happen			local newOwner;			if ownersA then				begin				local infoPath := [ pathExpr: 'owner, __ERUASym ];				while enRoute.transport._v_multiPOPCtr < Length(ownersA) do					begin					//fDoRead := nil;					newOwner := ownersA[enRoute.transport._v_multiPOPCtr];					if not IsSameEntry ( newOwner, enRoute.v_originalPersona ) then						begin						newOwner := ResolveEntryAlias ( newOwner );						local plmSym := :PLMSym ( newOwner );						if popInfo := Clone ( newOwner.(infoPath) ) then							begin							if StrFilled ( popInfo.enRoutePopHost )							and StrFilled ( popInfo.enRoutePopName )							and popInfo.enRoutePopPass							and Length ( popInfo.enRoutePopPass ) > 0 then								begin								popInfo.plmSym := plmSym;								popInfo.newOwner := ownersA[enRoute.transport._v_multiPOPCtr];								break;								end;							end;						end;					popInfo := newOwner := nil;					enRoute.transport._v_multiPOPCtr := enRoute.transport._v_multiPOPCtr + 1;					end;				end;			if newOwner then				begin				//fDoRead := true;				switchAccounts := true;				end;			newOwner := ownersA := nil;			end;		end;	inherited:TCP_Disconnect();	if switchAccounts then		begin		// set the new POP HOST which will be read into		// the "_v_Remote_HName" variable by "MCB_TCPUnbind"		:SetConfig ( 'enRoutePopHost, popInfo.enRoutePopHost );		// LRT - 97/05/11 3:07 PM		:SetConfig ( 'enRoutePopName, popInfo.enRoutePopName );		:SetConfig ( 'enRoutePopPass, popInfo.enRoutePopPass );	//	NOT REQUIRED for Multi-POP	//	:SetConfig ( 'enRouteSMTPHost,  popInfo.enRouteSMTPHost );	//	:SetConfig ( 'enRouteSignature, popInfo.enRouteSignature );		// set the new POP account directly		// as it isn't touched elsewhere	/*********************************************************************		local acct := popInfo.enRoutePopName;		local atPos := StrPos ( acct,"@",0 );		if atPos then			begin			acct := SubStr ( acct, 0, atPos );			end;		enRoute.account := acct;		// set the new fromAddress directly so that		// it can be used by the POP List routines		enRoute.fromAddress := Clone(popInfo.enRoutePopName);		if not StrPos ( enRoute.fromAddress,"@",0 ) then			begin			enRoute.fromAddress :=				enRoute.fromAddress & $@ & popInfo.enRoutePopHost;			end;		// set the new password directly		// as it isn't touched elsewhere		local pwd := popInfo.enRoutePopPass;		if ClassOf ( pwd ) = 'encrypted then			begin			local binPass := Clone ( pwd );			local int i;			for i := 0 to Length(binPass) - 1 do				begin				StuffByte(binPass,i,BXOr(0x65,ExtractByte(binPass,i)));				end;			pwd := ExtractCString ( binPass, 0 );			end;		enRoute.pass := pwd;	*********************************************************************/		enRoute.transport.epcon := func(site,owner,request,mode,howList,sendWithRx)			begin			inherited:epcon(site,popInfo.newOwner,request,mode,howList,sendWithRx);			enRoute.v_PLMSym := popInfo.plmSym;			printdepth := 0;			write ( "\nPatched enRoute: " );			print ( enRoute );			write ( "\n\n" );			RemoveSlot ( GetRoot().|EnRouteN1:Netstrategy|, 'epcon );			end;		// get ready for another if it exists		enRoute.transport._v_multiPOPCtr := enRoute.transport._v_multiPOPCtr + 1;		// Fake out "MCB_TCPUnbind" so that it will act as if we just		// completed a send session and will go ahead and perform		// a receive session next.		direction := 'Sending;		fDoRead := true;		_v_SMTPQuitting := true;		end;	end