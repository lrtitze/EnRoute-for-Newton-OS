/************************************************************************\\************************************************************************/#include <stdio.h>#include "objects.h"#include "NewtonScript.h"#include "applefile.h"typedef struct ParseInfo {	OSType		fType;	OSType		fCreator;	ULong		dataLen;	char		fName[64];} ParseInfo;static long _parseApplefile ( void * srcBinP, void * destBinP, ParseInfo *rslt );extern "C" Ref ParseApplefile ( RefArg rcvr, RefArg srcBinObj, RefArg destBinObj, RefArg infoFrame ){/*	if ( !IsBinary(srcBinObj) )		ThrowBadTypeWithFrameData ( -48408, srcBinObj );	// expected a binary object	if ( !IsBinary(destBinObj) )		ThrowBadTypeWithFrameData ( -48408, destBinObj );	// expected a binary object	if ( !IsFrame(infoFrame) )		ThrowBadTypeWithFrameData ( -48400, infoFrame );	// expected a frame*/	ParseInfo	parseInfo;	long		resultLength;	WITH_LOCKED_BINARY ( srcBinObj, srcP )	WITH_LOCKED_BINARY ( destBinObj, destP )	//	#ifdef forDebug	//		DebugStr ( "About to parse" );	//	#endif		resultLength = _parseApplefile ( srcP, destP, &parseInfo );	END_WITH_LOCKED_BINARY(srcBinObj)	END_WITH_LOCKED_BINARY(destBinObj)	RefVar	kindSymbol = SYM ( kind );	if ( resultLength == -1 )	{		SetVariable ( infoFrame, kindSymbol, SYM ( unknown ) );		parseInfo.dataLen = 0;		// tell caller to set length to 0!!!	}	else	{		switch ( parseInfo.fType )		{		case 'pkg ':			SetVariable ( infoFrame, kindSymbol, SYM ( package ) );			break;		case 'newt':			if ( parseInfo.fCreator == 'roµt' )				SetVariable ( infoFrame, kindSymbol, SYM ( enrouteFrame ) );			break;		case 'TEXT':			SetVariable ( infoFrame, kindSymbol, SYM ( text ) );			break;		default:			SetVariable ( infoFrame, kindSymbol, SYM ( unknown ) );			break;		}		UByte	*cP;		UniChar	uFType[5];		UniChar	uFCrea[5];		cP = (UByte *)&parseInfo.fType;		for ( short i = 0; i < 4; i++ )		{			uFType[i] = cP[i];		}		uFType[4] = 0;		SetVariable ( infoFrame, SYM ( fType ), MakeString ( uFType ) );		cP = (UByte *)&parseInfo.fCreator;		for ( short i = 0; i < 4; i++ )		{			uFCrea[i] = cP[i];		}		uFCrea[4] = 0;		SetVariable ( infoFrame, SYM ( fCreator ), MakeString ( uFCrea ) );		SetVariable ( infoFrame, SYM ( fName ), MakeString ( parseInfo.fName ) );	}	return MakeInt ( parseInfo.dataLen );}struct AF_Entry // an Applefile entry descriptor{	ULong	entryID; 	// entry type: see list, 0 invalid	ULong	entryOffset; // offset from beginning of file to entry's data	ULong	entryLength; // length of data in octets};typedef struct AF_Entry AF_Entry;static long _parseApplefile ( void * srcBinP, void * destBinP, ParseInfo *rslt ){	register long	* entryP = (long *)( (long)srcBinP + 26 );	ULong		* lP = (ULong *)srcBinP;	void 		* eDataP;	void	* dataStart;	long	dataLen = -1;	OSType	typ     = 0x3F3F3F3F;	// '????';	OSType	crea    = 0x3F3F3F3F;	// '????';	char	dbgStr[512];	if ( ( *lP == 0x00051600 ) || ( *lP == 0x0051607 ) )	// AppleSingle or AppleDouble	{		short	* sP = (short *)srcBinP;		short	numEntries = sP[12];		AF_Entry	thisOne;		for ( short i = 0; i < numEntries; i++, entryP += 3 )		{			BlockMove ( (void *)entryP, &thisOne, 12 );		//	#ifdef forDebug		//		sprintf ( dbgStr, "entryID = %d", thisOne.entryID );		//		DebugStr ( dbgStr );		//	#endif			eDataP = (void *)( (ULong)srcBinP + thisOne.entryOffset );			ULong	sz = thisOne.entryLength;			switch ( thisOne.entryID )			{			case 1:						// AS_DATA				dataStart = eDataP;				dataLen = (long)sz;				break;			case 3:						// AS_REALNAME				if ( sz > 63 ) sz = 63;				BlockMove ( eDataP, rslt->fName, sz );				rslt->fName[sz] = 0;				break;			case 9:						// AS_FINDERINFO				BlockMove ( eDataP, &typ, 4 );				BlockMove ( (void *)( (long)eDataP + 4 ), &crea, 4 );				break;			}		}		rslt->fType    = typ;		rslt->fCreator = crea;		if ( (typ == 'pkg ')		||   (typ == 'newt' && crea == 'roµt')		||   (typ == 'TEXT') )		{			if ( dataLen > 0 )			{				BlockMove ( dataStart, destBinP, dataLen );			}			if ( typ == 'TEXT' )			{				char	* txtP = (char *)dataStart;				txtP[dataLen] = 0;				dataLen++;			}			rslt->dataLen  = dataLen;		}	}	return dataLen;}/************************************************************	char	fileName[64] = "Some kind of file is here";	rslt->fType = 'pkg ';	rslt->fCreator = 'pkgX';	rslt->dataLen = 17;	BlockMove ( fileName, rslt->fName, 64 );	dataLen = rslt->dataLen;	return dataLen;}/*void BlockMove ( const void * srcPtr, void * destPtr, Size byteCount );void			DisposPtr(Ptr p);Size			GetPtrSize(Ptr p);Ptr				NewPtr(Size size);Ptr				NewPtrClear(Size byteCount);Heap			PtrToHeap(Ptr);Ptr				ReallocPtr(Ptr, Size);			// like reallocSize			TotalFreeInHeap(Heap DEFAULT_NIL);Size			LargestFreeInHeap(Heap DEFAULT_NIL);unsigned long	CountFreeBlocks(Heap DEFAULT_NIL);Size			TotalUsedInHeap(Heap DEFAULT_NIL);Size			MaxHeapSize(Heap DEFAULT_NIL);//____________________________________________________________________// Frame & Slot Functionsextern	Ref		AllocateFrame(void);extern	Boolean	FrameHasPath(RefArg obj, RefArg thePath);extern	Boolean	FrameHasSlot(RefArg obj, RefArg slot);extern	Ref		GetFramePath(RefArg obj, RefArg thePath);extern	Ref		GetFrameSlot(RefArg obj, RefArg slot);extern	long	Length ( RefArg obj );		// Length in bytes or slotsextern	void	MapSlots(RefArg obj, MapSlotsFunction func, ULong anything);extern	void	RemoveSlot(RefArg frame, RefArg tag);extern	void	SetFramePath(RefArg obj, RefArg thePath, RefArg value);		extern	void	SetFrameSlot(RefArg obj, RefArg slot, RefArg value);extern	void	SetLength(RefArg obj, long length);extern	Ref		MakeString(const char* str);*/