// datadefs for rules picker//	RegisterDataDef ( k_RuleNameRefDDef );//	UnregisterDataDef ( k_RuleNameRefSymbol );constant k_Debug_GET := nil;DefConst ( 'k_RuleNameRefSymbol, '|nameRef.ruleset:EnRouteN1| );DefConst ( 'k_RuleNameRefDDef, {	_proto:				protoNameRefDataDef,	// protoPeopleDataDef,	class:				k_RuleNameRefSymbol,	symbol:				k_RuleNameRefSymbol,	soupToQuery:		k_ruleSoupName,	singleSelect:		true,	primaryPath:		'title,	_sortPath:			'title,	name:				LocObj ( "Rule Filters", 'nameRef.name ),//	superSymbol:		 kSuperSymbol,	// '|Rulesets:EnRoute|	columns: [		{		fieldPath: 'title,		getPath: 'title,		optional: nil,		tapWidth: 0,		noPopup: TRUE,		},	],	GetPrimaryPath: func(p) primaryPath,	querySpec: {		type:		'index,		indexPath:	'title,		// 'timeStamp,	//'title,		},	MakeNameRef: func ( item, dataClass )		begin		// from page 6-23 of NPG-System		local nameRef := inherited:MakeNameRef ( item, dataClass );		local aEntry := EntryFromObj ( item );		nameRef.title := aEntry.title;		nameRef.ruleFilter := aEntry.ruleFilter;		nameRef.ruleFnsA := aEntry.ruleFnsA;		nameRef;		end,	StringExtract: func(item,arg)		begin		(if item.title then			item.title;		else LocObj ( "Untitled", 'nameRef.untitled )		);		end, 	HitItem: func ( tapInfo, context ) 		begin	//	if kDebugOn then print ( "HitItem" );	//	if kDebugOn then write ( "tapInfo " );	//	if kDebugOn then print ( tapInfo );		context:Tapped ( 'toggle );		_tapinfo := nil;		_dirtyPaths := nil;		_dirtyValues := nil; 		return nil;		end, 	GetSuffix: func ( object ) 		begin		if kDebugOn and k_Debug_GET then print ( "GetSuffix" && object.title ); 		return "";		end,	Get: func ( object, fieldPath, format )		begin		if fieldPath = 'name then			fieldPath := 'title;		local data := inherited:Get ( object, fieldPath, format );		if not data then data := LocObj ( "UNKNOWN", 'nameRef.unknownName );		if kDebugOn and k_Debug_GET then print ( "Get ( '" & fieldPath & ", '" & format && $) && "-->" && data );		data;		end,	MakePopup: func ( object, fieldPath )		begin		if kDebugOn then print ( "MakePopup" );		nil;		end,	Validate: func ( item, fields )		begin		if kDebugOn then print ( "Validate (" && item.title && $) );	//	print ( item );	//	print ( fields );		[];		end,	GetRoutingTitle: func ( objects, width, font )		begin		if kDebugOn and k_Debug_GET then print ( "GetRoutingTitle" );		local title;		if objects and not IsArray(objects) then			title := :Get ( objects, primaryPath, 'text );		else if objects and Length(objects) > 0 then			begin			local item;			foreach item in objects do				begin				local tempTxt := :Get ( item, primaryPath, 'text );				if title and StrFilled(title) then					title := ParamStr ( "^0, ^1", [title, tempTxt] );				else					title := tempTxt;				if font and width then					if StrFontWidth ( title, font ) > width then						break;				end;			if title and StrFilled(title) and font and width then				title := StyledStrTruncate ( Clone(title), width, font );			end;		else			title := LocObj ( "None", 'nameRef.noTitle );		title;		end,	DefaultEditDone: func ( modified )		begin		if modified then			begin			inherited:DefaultEditDone ( modified );			end;		else			begin			_context:?Tapped ( nil );			_tapinfo := nil;			_dirtyPaths := nil;			_dirtyValues := nil			end;		end,} );