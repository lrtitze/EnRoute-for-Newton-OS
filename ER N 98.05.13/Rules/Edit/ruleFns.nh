// rules filter Get and Test function definitions// with "kRF_FuncDefFrame" for actual filteringDefConst ( 'kRF_Subj_GetFn, func ( msg )	begin	if msg.title then msg.title else k_EmptyStr;	end );DefConst ( 'kRF_From_GetFn, func ( msg )	begin	// LRT - 97/05/03 1:07 AM	// Added code to N1_Service "SM_POPHeader" to check for	// "Sender:" info and put it with "From:" into "txtFrom" slot	// WAS:	// if msg.fromRef then	// NEW:	if msg.txtFrom then msg.txtFrom	else if msg.fromRef then		begin		msg.fromRef.name.first			&& msg.fromRef.name.last			&& msg.fromRef.email;		end;	else k_EmptyStr;	end );DefConst ( 'kRF_Dest_GetFn, func ( msg )	begin	if msg.txtDest then msg.txtDest else k_EmptyStr;	end );DefConst ( 'kRF_TO_GetFn, func ( msg )	begin	if msg.txtTo then msg.txtTo else k_EmptyStr;	end );DefConst ( 'kRF_CC_GetFn, func ( msg )	begin	if msg.txtCC then msg.txtCC else k_EmptyStr;	end );DefConst ( 'kRF_Prio_GetFn, func ( msg )	begin	local p := msg.priority;	if p then		begin		if IsString(p) then			begin			p := StringToNumber(p);			if not p then				begin				p := msg.priority;				if StrPos ( p, "normal", 0 ) then					p := 2;				else if StrPos ( p, "highest", 0 ) then					p := 0;				else if StrPos ( p, "high", 0 ) then					p := 1;				else if StrPos ( p, "lowest", 0 ) then					p := 4;				else if StrPos ( p, "low", 0 ) then					p := 3;				end;			else	// LRT - 97/08/27 5:01 AM				p := p - 1;			end;		end;	if not p then p := 3;	p;	end );DefConst ( 'kRF_When_GetFn, func ( msg )	begin	if msg.when then msg.when else "0";	end );DefConst ( 'kRF_Age_GetFn, func ( msg )	begin	local date := if msg.when then msg.when else "0";	Time() - date;	end );DefConst ( 'kRF_Size_GetFn, func ( msg )	begin	if msg.size then msg.size else 0;	end );DefConst ( 'kRF_StrContain_TstFn, func ( msgData, tst )	begin	if StrLen(tst) = 0 then		return  (StrLen(msgData) = 0);	not (StrPos ( msgData, tst, 0 ) = nil);	end );DefConst ( 'kRF_StrNotContain_TstFn, func ( msgData, tst )	begin	if StrLen(tst) = 0 then		return  not (StrLen(msgData) = 0);	(StrPos ( msgData, tst, 0 ) = nil);	end );DefConst ( 'kRF_StrBeginsWith_TstFn, func ( msgData, tst )	begin	if StrLen(tst) = 0 then		return  (StrLen(msgData) = 0);	BeginsWith ( msgData, tst );	end );DefConst ( 'kRF_StrNotBeginsWith_TstFn, func ( msgData, tst )	begin	if StrLen(tst) = 0 then		return  not (StrLen(msgData) = 0);	not (BeginsWith ( msgData, tst ));	end );DefConst ( 'kRF_NumCompare_TstFn, func ( a, b )	begin	//if kDebugOn then print ( a && "---" && b );	if IsString ( a ) then a := StringToNumber(a);	if not a then a := 0;	if IsString ( b ) then b := StringToNumber(b);	if not b then b := 0;	//if kDebugOn then print ( a && "---" && b );	if a > b then 1;		// 1 if a > b	else if a = b then 0;	else -1;				// negative if a < b	end );DefConst ( 'kRF_NumEqual_TstFn, func ( msgData, tst )	begin	(call kRF_NumCompare_TstFn with ( msgData, tst )) = 0;	end );DefConst ( 'kRF_NumNotEqual_TstFn, func ( msgData, tst )	begin	not (call kRF_NumCompare_TstFn with ( msgData, tst )) = 0;	end );DefConst ( 'kRF_NumGreaterOrEqual_TstFn, func ( msgData, tst )	begin	(call kRF_NumCompare_TstFn with ( msgData, tst )) >= 0;	end );DefConst ( 'kRF_NumGreaterThan_TstFn, func ( msgData, tst )	begin	(call kRF_NumCompare_TstFn with ( msgData, tst )) > 0;	end );DefConst ( 'kRF_NumLessThan_TstFn, func ( msgData, tst )	begin	(call kRF_NumCompare_TstFn with ( msgData, tst )) < 0;	end );DefConst ( 'kRF_FuncDefFrame, {	gSubj:	kRF_Subj_GetFn,	gFrom:	kRF_From_GetFn,	gTo:	kRF_TO_GetFn,	gCC:	kRF_CC_GetFn,	gDest:	kRF_Dest_GetFn,	gPrio:	kRF_Prio_GetFn,	gWhen:	kRF_When_GetFn,	gAge:	kRF_Age_GetFn,	gSize:	kRF_Size_GetFn,	tStrEQ:	kRF_StrContain_TstFn,	tStrNE:	kRF_StrNotContain_TstFn,	tStrBW:	kRF_StrBeginsWith_TstFn,	tStrNB:	kRF_StrNotBeginsWith_TstFn,	tNumEQ:	kRF_NumEqual_TstFn,	tNumNE:	kRF_NumNotEqual_TstFn,	tNumGE:	kRF_NumGreaterOrEqual_TstFn,	tNumGT:	kRF_NumGreaterThan_TstFn,	tNumLT:	kRF_NumLessThan_TstFn,	} );DefConst ( 'kRF_HasLabelsFunc, func(a,b)	begin	HasSlot ( b, 'labels );	end );DefConst ( 'kRF_TestRuleFunc, func(msg,rule)	begin	try	local data := call kRF_FuncDefFrame.(rule.getDFn) with (msg);	local pass := call kRF_FuncDefFrame.(rule.tstFn) with (data, rule.tstData);	onexception |evt.ex| do return 'reject;	// pass := nil;	if pass then		begin		if HasSlot ( rule, 'labels ) and not msg.labels then			begin			if kDebugOn then print ( "Setting labels to" && rule.labels );			msg.labels := rule.labels;			end;		if HasSlot ( rule, 'accept ) and not msg._filterAccept then			begin			if not rule.accept then				return 'reject;			else				begin				if kDebugOn then print ( "Setting _filterAccept" );				msg._filterAccept := 'accept;				if msg.labels then					return 'accept;				end;			end;		/*********** OLD WAY *****************		if rule.accept then return 'accept;		else return 'reject;		**************************************/		end;	nil;	end );DefConst ( 'kRF_SimpleTestFunc, func(msg,rule)	begin	try	local data := call kRF_FuncDefFrame.(rule.getDFn) with (msg);	local pass := call kRF_FuncDefFrame.(rule.tstFn) with (data, rule.tstData);	onexception |evt.ex| do return 'reject;	// pass := nil;	if pass then		begin		if rule.accept then return 'accept;		else return 'reject;		end;	nil;	end );