DefConst ( 'k_SwitchBoxViewFunc, func(whichBox)	begin	local theBox := GetRoot().iobox;	if not call kViewIsOpenFunc with (theBox) then		theBox:OpenAsInBox();	else if call kViewIsOpenFunc with (theBox) then		theBox:SetBox ( whichBox );	end );DefConst ( 'k_ReplaceStrInksFunc, func(str)	begin	if IsRichString ( str ) then		begin		StripInk ( str, $\uFC02 );	// kPopSpace		StrReplace ( str, "\uFC02", LocObj ( "-ink-", 'inkConvert.inkSubstitute ), nil );		end;	str;	end );/*********************************************DefConst ( 'k_BodyWrapPrepareFunc, func(txt)	begin	local tempBody := txt;	call k_ReplaceStrInksFunc with ( tempBody );	try	if StrLen ( txt ) < 2000 then		tempBody := Clone(txt);	else		begin		tempBody := GetDefaultStore():NewVBO('string,2);		StrMunger ( tempBody, 0, nil, txt, 0, nil );		if K_FIX_VBO_WITH_ENTRY then			begin			// LRT - 97/01/11 4:34 PM			// fix for disappearing VBO space			// - put VBO into a soup entry			local entryTemp := {				d:		tempBody,				tag:	'_vbo,				};			local store :=				if IsVBO ( _VBO_dataStoreTemp ) then					GetVBOStore ( _VBO_dataStoreTemp );				else					:GetDefaultOwnerStore();			local soup := GetUnionSoupAlways ( k_infoSoupName );			soup:AddToStoreXmit ( _VBO_entryTemp, store, nil );			end;		end;	onexception |evt.ex| do tempBody := txt;	tempBody;	end );*********************************************/DefConst ( 'k_AddrFrom822Func, func(addr822)	begin	local i;	if not addr822 then addr822 := "?????";	addr822 := TrimString ( addr822 );	try 		local temp822 := Clone ( addr822 );		if BeginsWith ( temp822, "\"" ) then			temp822[0] := $\u0020;		if EndsWith ( temp822, "\"" ) then			temp822[StrLen(temp822) - 1] := $\u0020;		temp822 := TrimString ( temp822 );		local nameF :=			{			name: { first: Clone(k_EmptyString), last: temp822, },			email: Clone ( temp822 ),			};		SetClass ( nameF.email, '|string.email.internet| );		local namePart := k_EmptyString;		local closePos;		local spacePos;		// LRT - 96/11/16 3:26 AM		// test was too simple to cope with		// "Bruce Thompson <bruce@newton.apple.com> (by way of rcampos@idirect.com (Robert"		//local bracePos := EndsWith ( addr822, ">" )		local bracePos := EndsWith ( addr822, ">" )			or ( StrPos ( addr822, "<", 0 ) and StrPos ( addr822, ">", 0 ) );		local parenPos := StrPos ( addr822, "(", 0 );		if bracePos then			begin			// ADDR: "John Doe" <jondoe@place.com>			bracePos := 0;			for i := StrLen(addr822) to 1 by -1 do				begin				if addr822[i-1] = $< then					begin					bracePos := i-1;					break;					end;				end;			closePos := CharPos ( addr822, $>, bracePos );			local addrPart := Substr ( addr822, bracePos+1, closePos - bracePos - 1 );			nameF.email := addrPart;			// try to strip off the quoted name			if addr822[0] = $" then				begin				for i := StrLen(addr822) to 1 by -1 do					begin					if addr822[i-1] = $" then						begin						closePos := i-1;						break;						end;					end;				local namePart := Substr ( addr822, 1, closePos - 1 );				end;			else				begin				for i := bracePos to 1 by -1 do					begin					if addr822[i-1] = $\20 then						begin						closePos := i-1;						break;						end;					end;				local namePart := Substr ( addr822, 0, closePos );				end;			end;		else if parenPos then			begin			// ADDR: jondoe@place.com (John Doe)			// ADDR: jondoe@place.com (John Q. Doe)			// ADDR: jondoe@place.com (John)			parenPos := 0;			for i := StrLen(addr822) to 1 by -1 do				begin				if addr822[i-1] = $( then					begin					parenPos := i-1;					break;					end;				end;			closePos := CharPos ( addr822, $), parenPos );			namePart := Substr ( addr822, parenPos+1, closePos - parenPos - 1 );			nameF.email := Substr ( addr822, 0, parenPos - 1 );			end;		if StrFilled ( namePart ) then			begin			spacePos := -1;			// LRT - 97/04/22 2:13 AM			// WAS:			// if CharPos ( namePart, $\20, 0 ) then			// NEW:			if ( spacePos := CharPos ( namePart, $\2C, 0 ) ) then				begin				// has a comma therefore is "Last, First"				nameF.name.last  := Substr ( namePart, 0, spacePos );				nameF.name.first := Substr ( namePart, spacePos+1, 9999 );				end;			else if CharPos ( namePart, $\20, 0 ) then	// END OF NEW  97/04/22				begin				for i := StrLen(namePart) to 1 by -1 do					begin					if namePart[i-1] = $\20 then						begin						spacePos := i - 1;						break;						end;					end;				nameF.name.last := Substr ( namePart, spacePos+1, 9999 );				nameF.name.first  := Substr ( namePart, 0, spacePos );				end;			else				begin				nameF.name.last := namePart;			//	nameF.name.first := Clone(k_EmptyString);				end;			end;		if bracePos or parenPos then			begin			StrReplace ( nameF.name.first, "\"", k_EmptyString, nil );			StrReplace ( nameF.name.last,  "\"", k_EmptyString, nil );			// LRT - 97/04/22 1:49 AM			// undo opt-quotes from "k_822QuotesToOptsFunc"			StrReplace ( nameF.name.first, "\u005C00A8", "\u0022", nil );			StrReplace ( nameF.name.last,  "\u005C00A8", "\u0022", nil );			TrimString ( nameF.name.first );			TrimString ( nameF.name.last );			if nameF.email then				begin				StrReplace ( nameF.email, " ", k_EmptyString, nil );				TrimString ( nameF.email );				SetClass   ( nameF.email, '|string.email.internet| );				end;			end;	onexception |evt.ex| do		begin		nameF.name.first := k_EmptyString;		nameF.name.last  := addr822;		nameF.email      := Clone ( addr822 );		if nameF.email then			begin			StrReplace ( nameF.email, " ", k_EmptyString, nil );			end;		end;	nameF;	end );DefConst ( 'k_UnfoldedATo822Func, func ( unfAddrA )		// verrichten	begin	if not unfAddrA then return k_EmptyString;	local outStr := k_EmptyString;	local maxOnLine := 64 - 4;	for i := 0 to Length(unfAddrA) - 1 do		begin		local s := "<" & unfAddrA[i].addr & ">";		if StrLen(s) > 2 then			begin			local appendPos := StrLen(outStr)-1;			outStr := outStr &				unfAddrA[i].qName &&				s				& ", ";			if StrLen(outStr) > maxOnLine then				begin				StrMunger ( outStr, appendPos, 0, "\u000D000A\u   ", 0, 5 );				maxOnLine := 64;				end;			end;		end;	outStr := TrimString(outStr);	if EndsWith ( outStr, "," ) then		begin		outStr[StrLen(outStr)-1] := $\20;		outStr := TrimString(outStr);	// & "\u000D000A";		end;	outStr;	end );DefConst ( 'k_BuildSMTPMsgAddrsFunc, func(msg)		// verrichten	begin	if kDebugOn and k_DbgOutAddresses then print ( ":BuildSMTPMsgAddrs(msg)" );	msg._toA := if msg.toRef then		:UnfoldAddressA ( msg.toRef );	local toRCPTCount := if msg._toA then		Length ( msg._toA ) else 0;	msg._ccA := if msg.cc then		:UnfoldAddressA ( msg.cc );	local ccRCPTCount := if msg._ccA then		Length ( msg._ccA ) else 0;	msg._bccA := if msg.bcc then		:UnfoldAddressA ( msg.bcc );	local bccRCPTCount := if msg._bccA then		Length ( msg._bccA ) else 0;	// create our output address array here	msg._outAddresses := [];		// addresses we'll send to	msg._badAddresses := [];		// collected invalid ones	local fillupFunc := func ( rcptKind, theArray )		begin		local s;		local addr;		foreach addr in theArray do			begin			local s := "<" & addr.addr & ">";			if StrLen(s) > 2 then				begin				AddArraySlot ( msg._outAddresses,					{					kind: rcptKind,		// one of [ 'to, 'cc, 'bcc ]					smtp: s,			// RCPT TO:<Jones@BBN-UNIX.ARPA>					addr: addr,					} );				end;			else				begin				// the chosen address cannot be used				AddArraySlot ( msg._badAddresses, addr.orig );				end;			end;		end;	if toRCPTCount > 0 then		begin		call fillupFunc with ( 'ato, msg._toA );		end;	if ccRCPTCount > 0 then		begin		call fillupFunc with ( 'cc, msg._ccA );		end;	if bccRCPTCount > 0 then		begin		call fillupFunc with ( 'bcc, msg._bccA );		end;	end );DefConst ( 'k_EncMakeHeaderFunc, func(msg)		// verrichten	begin	local funcSMungeAppend := k_SMungeAppendFunc;	local funcStrMungeCRLF := k_StrMungeCRLFFunc;	// boundary marker has already been transmitted	local enc := msg.encFrame;	if not enc.fName or not StrFilled(enc.fName) then		enc.fName := k_UntitledString;	// LRT - 97/04/15 9:07 AM	// Replace inline code with call to function	// WAS:	/********************************************************	// LRT - 97/03/24 4:47 PM	// WAS:	//enc.fName := TrimString ( enc.fName );	// NEW:	local usAscii;	local convFunc := func ( str, newOff )		begin		usAscii := str;		nil;			// exit from "kWrapTxAsyncFunc"		end;	local bin := MakeBinary ( 512, 'binary );	call kWrapTxAsyncFunc with ( enc.fName, bin,		0, 128, convFunc, NIL );	TrimString ( usAscii );		// remove trailing <CR>	enc.fName := usAscii;	********************************************************/	// NEW:	enc.fName := call k_SpecialToUSAsciiFunc with ( enc.fName );	if not StrFilled(enc.fName) then		enc.fName := k_UntitledString;	// add 2 <CR><LF> pairs and a boundary marker to begin this part	local header := Clone ( k_EmptyString );	call funcStrMungeCRLF with ( header );	call funcStrMungeCRLF with ( header );	call funcSMungeAppend with ( header, "--" );	call funcSMungeAppend with ( header, msg.boundary );	call funcStrMungeCRLF with ( header );	// add a MIME header	// LRT - 97/04/11 5:44 AM	// ensure that the filename line is short enough for	// Eudora Desktop	// WAS:	//local ctStr := "Content-Type: application/octet-stream ; name=\""	//	& enc.fName & $";	// NEW:	local ctStr := "Content-Type: application/octet-stream\u000D000A\u ; name=\""		& SubStr ( enc.fName, 0, 51 ) & $";	call funcSMungeAppend with ( header, ctStr );	call funcStrMungeCRLF with ( header );	// file name for uuencode in MS-DOS format	// strip all but alphanumerics from short file name!!	local shortFName := call k_StrToAlphaNumOnlyFunc with ( enc.fName );	shortFName := SubStr ( shortFName, 0, 8 );	// file type and creator in Eudora Macintosh format	if enc.fType then		begin		if StrEqual ( enc.fType, "pkg " ) then			shortFName := shortFName & ".pkg";		else if StrEqual ( enc.fType, "\u0096\uewt" ) then			shortFName := shortFName & ".nwt";		else	// everybody else can name it as they please!!			shortFName := enc.fName;		call funcSMungeAppend with ( header, " ; x-mac-type=" );		call funcSMungeAppend with ( header,			call k_StrToHexQuotedOSTypeFunc with ( enc.fType ) );		call funcStrMungeCRLF with ( header );		end;	if enc.fCreator then		begin		call funcSMungeAppend with ( header, " ; x-mac-creator=" );		call funcSMungeAppend with ( header,			call k_StrToHexQuotedOSTypeFunc with ( enc.fCreator ) );		call funcStrMungeCRLF with ( header );		end;	call funcSMungeAppend with ( header,		"Content-Transfer-Encoding: x-uuencode\u000D000A\u" );	// begin with 2 blank lines	call funcStrMungeCRLF with ( header );	call funcStrMungeCRLF with ( header );	// begin uuencoded file	call funcSMungeAppend with ( header, "begin 644 " );	call funcSMungeAppend with ( header, Upcase(shortFName) );	call funcStrMungeCRLF with ( header );	header;	end );/********************************************Ã allHeaders: [#8]Ã boundary: "Cyberdog-AltBoundary-003AC10E"Ã contentType: 'multipartÃ fromCyberdog: TRUEÃ fullHeader: ""Ã id: 12Ã isMime: TRUEÃ multipart: TRUEÃ parts: [alternative:#1]Ã size: 35059Ã startOfBody: 0Ã subType: 'alternativeÃ textpartFound: TRUEÃ txtTo: ""Les -io- Titze" <lrtitze@io.org>"Ã xferEncoding: '7bit*************************************************/DefConst ( 'k_localStripSlotsArray, '[		fromEnRoute,		subType,		parts,		fullBody,			isMime,			isText,		__ctParms,			dateString,		multipart,			msgID,			UID,		boundary,			id,				fullyResolved,		txtFrom,			txtTo,			txtCC,		txtReplyTo,		txtDest,			startOfBody,		size,				fullHeader,		octetParts,		allHeaders,			skippedSynopsis,		xferEncoding,		textpartFound,		contentType,		subType,				elapsedTime,		// fName,		] );DefConst ( 'k_CleanRxMessageFunc, func(msg)		// verrichten	begin	if kDebugOn then		begin		if k_DoNotCleanRxMsg then return;		end;	// Extensions	if transport exists and transport.rxExtns	and Length ( transport.rxExtns ) > 0 then		begin		local extn;		foreach extn in transport.rxExtns do			begin			local xf := {				_parent:	self,				_proto:		extn,				};			try xf:?XPreCleanRx ( msg );			onexception |evt.ex| do nil;			end;		end;	// Clean it all up	local array stripA := k_localStripSlotsArray;	local int i;	for i := 0 to Length ( stripA ) - 1 do		begin		RemoveSlot ( msg, stripA[i] );		end;	end );