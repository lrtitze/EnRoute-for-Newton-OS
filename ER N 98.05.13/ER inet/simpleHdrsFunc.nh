// LRT - 97/10/25 6:29 PM// 1.4.3// Used by inputSpec "POPHeader"//// When someone sends a message with an unusually large// header, it can actually throw due to lack of heap!DefConst ( 'k_SimpleHdrsFunc, func ( theTxt )	begin	//******************************************************	// Returns a new message header containing the MINIMUM	// set of required data for EnRoute i-net	//******************************************************	local sPos, tempTxt, tempPos;	local rtnHdr := Clone ( "" );	local funcUnwrappedLine := k_UnwrappedLineFunc;	sPos := StrPos ( theTxt, "\nFrom:", 0);	if not sPos then		// Somewhere out there is an email client that says ">From :"		sPos := StrPos ( theTxt, "\n>From :", 0 );	if sPos then		begin		tempTxt := call funcUnwrappedLine with ( theTxt, sPos );		rtnHdr := rtnHdr & tempTxt;		end;	sPos := StrPos ( theTxt, "\nSubject:", 0);	if not sPos then		// Somewhere out there is an email client that says "\nSubj:"		sPos := StrPos ( theTxt, "\nSubj:", 0 );	if sPos then		begin		tempTxt := call funcUnwrappedLine with ( theTxt, sPos );		rtnHdr := rtnHdr & tempTxt;		end;	local array hdrIDsA := '[		"\nDate:",		"\nSender:",		"\nTo:",		"\ncc:",		"\nMessage-ID:",		"\nX-Mailer",		"\nMime-Version",		"\nContent-Type:",		"\nContent-Transfer-Encoding:",		"\nPriority:",		"\nStatus:",		"\nTo:",		];	local strposFunc := GetGlobalFn ( 'StrPos );	local int n;	for n := 0 to Length(hdrIDsA)-1 do		begin		sPos := call strposFunc with ( theTxt, hdrIDsA[n], 0 );		if sPos then			begin			tempTxt := call funcUnwrappedLine with ( theTxt, sPos );			rtnHdr := rtnHdr & tempTxt;			end;		end;	// try to catch the last complete line of data from the final <CR>	// of the source text to use as the terminal line of the new hdr	local n := StrLen(theTxt)-1;	local final := "" & theTxt[n];	local prev := theTxt[n];	n := n - 1;	while n > 0 do		begin		local ch := theTxt[n];		final := ch & final;		if ch = $\0D then			begin			if not ( prev = $\20 or prev = $\09 or prev = $\n ) then				break;			end;		prev := ch;		n := n-1;		end;	rtnHdr := rtnHdr & final;	if kDebugOn then		begin		write ( "\n **** NEW HEADER CREATED *****\n" );		print ( rtnHdr );		write ( "\n" );		end;	rtnHdr;	end );