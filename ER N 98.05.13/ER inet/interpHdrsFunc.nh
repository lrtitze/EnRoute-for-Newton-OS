DefConst ( 'k_InterpHeadersFunc, func ( theTxt, msgPart )	begin	local sPos, tempTxt, tempPos;	local funcUnwrappedLine := k_UnwrappedLineFunc;	// CONTENT-DISPOSITION:	sPos := StrPos ( theTxt, "Content-Disposition:", 0 );	if sPos then		begin		sPos := CharPos ( theTxt, $:, sPos );		tempTxt := TrimString(call funcUnwrappedLine with ( theTxt, sPos+1 ));		try		tempText := SplitString(tempTxt)[0];		msgPart.disposition := Intern ( tempText );		onexception |evt.ex| do nil;		end;	// CONTENT-TYPE:	sPos := StrPos ( theTxt, "Content-Type:", 0 );	if sPos then		begin		sPos := CharPos ( theTxt, $:, sPos );		if sPos then			begin			tempTxt := TrimString(call funcUnwrappedLine with ( theTxt, sPos+1 ));			local tokFunc := StrTokenize ( tempTxt, $; );			local param;			local paramsA := [];			while param := call tokFunc with () do				begin				AddArraySlot ( paramsA, param );				end;			tempTxt := TrimString ( paramsA[0] );			ArrayRemoveCount ( paramsA, 0, 1 );			foreach param in paramsA do				begin				if not msgPart.__ctParms then msgPart.__ctParms := {};				sPos := CharPos ( param, $=, 0 );				if sPos then					begin					local fld := TrimString( SubStr( param, 0, sPos ) );					local val := TrimString( SubStr( param, sPos+1, 0x3FFFFFF ) );					if BeginsWith ( val, "\"" ) then						val[0] := $\20;					if EndsWith ( val, "\"" ) then						val[StrLen(val)-1] := $\20;					val := TrimString(val);					if EndsWith ( fld, "name" ) then						msgPart.fName := val;					else						msgPart.__ctParms.( Intern(fld) ) := val;					end;				end;			tokFunc := StrTokenize ( tempTxt, $/ );			paramsA := [];			while param := call tokFunc with () do				begin				AddArraySlot ( paramsA, param );				end;			tempTxt := TrimString ( paramsA[0] );			if Length ( paramsA ) > 0 then				begin				msgPart.contentType := Intern ( TrimString ( paramsA[0] ) );				if Length ( paramsA ) > 1 then					begin					msgPart.subType := Intern ( TrimString ( paramsA[1] ) );					end;				end;			if msgPart.contentType = 'text then				begin				msgPart.isText := true;				if msgPart.subType = 'enriched then					msgPart.enrichedText := true;				end;			else if msgPart.contentType = 'multipart then				begin				if msgPart.__ctParms.boundary then					begin					msgPart.boundary := msgPart.__ctParms.boundary;					RemoveSlot ( msgPart.__ctParms, 'boundary );					end;				else					msgPart.boundary := "\n--\n";		// pretty bad, but worst case				msgPart.multipart := true;				end;			else if msgPart.contentType = 'application then				begin				msgPart.applicType := true;				if msgPart.subType = '|octet-stream| then					msgPart.enclosure := 'octetStream;				else if msgPart.subType = '|mac-binhex40| then					msgPart.enclosure := 'binhex;				end;			// LRT - 98.02.20 1:53 AM			// NEW in 1.4.3a02			// message/rfc822			else if msgPart.contentType = 'message then				begin				if msgPart.subType = 'rfc822 then					msgPart.isText := true;				end;			else if nil then				begin				sPos := CharPos ( tempTxt, $/, 0 );				if sPos then					begin					msgPart.contentType := Intern( SubStr( tempTxt, 0, sPos ) );					msgPart.subType := Intern( SubStr( tempTxt, sPos+1, 99999 ) );					end;				else					msgPart.contentType := Intern( tempTxt );				end;			end;		end;	else		msgPart.isText := true;	sPos := StrPos ( theTxt, "\nContent-Transfer-Encoding", 0 );	// CONTENT-TRANSFER-ENCODING:	if sPos then		begin		sPos := CharPos ( theTxt, $:, sPos );		if sPos then			begin			tempTxt := call funcUnwrappedLine with ( theTxt, sPos+1 );			tempTxt := TrimString ( tempTxt );			local tokFunc := StrTokenize ( tempTxt, $; );			local param;			local paramsA := [];			while param := call tokFunc with () do				begin				AddArraySlot ( paramsA, param );				end;			tempTxt := TrimString ( paramsA[0] );			ArrayRemoveCount ( paramsA, 0, 1 );			msgPart.xferEncoding := Intern(tempTxt);			foreach param in paramsA do				begin				if not msgPart.__teParms then msgPart.__teParms := {};				sPos := CharPos ( param, $=, 0 );				if sPos then					begin					local fld := TrimString( SubStr( param, 0, sPos ) );					local val := TrimString( SubStr( param, sPos+1, 0x3FFFFFF ) );					if BeginsWith ( val, "\"" ) then val[0] := $\20;					if EndsWith   ( val, "\"" ) then val[StrLen(val)-1] := $\20;					val := TrimString(val);					if EndsWith ( fld, "name" ) then						msgPart.fName := val;					msgPart.__teParms.( Intern(fld) ) := val;					end;				end;			if msgPart.xferEncoding = '|quoted-printable| then				msgPart.quotedPrintable := true;			end;		end;	else		msgPart.xferEncoding := '|7bit|;	if not msgPart.contentType then		begin		msgPart.contentType := 'text;		msgPart.subType := 'plain;		msgPart.isText := true;		end;	if not msgPart.xferEncoding then		begin		msgPart.xferEncoding := '|7bit|;		end;	if msgPart.__ctParms and Length(msgPart.__ctParms) = 0 then		RemoveSlot ( msgPart, '__ctParms );	if msgPart.__teParms and Length(msgPart.__teParms) = 0 then		RemoveSlot ( msgPart, '__teParms );	end );