DefConst ( 'k_UniqueMarkStart, "****--" );	// "========--" );DefConst ( 'k_UniqueMarkFinir, "--****" );	// "--========" );DefConst ( 'k_UniqueMarkerFunc, func(body)	begin	local n := Time();	local test := k_UniqueMarkStart & n & k_UniqueMarkFinir;	while StrPos(body,test,0) do		begin		n := n + 61;		test := k_UniqueMarkStart & n & k_UniqueMarkFinir;		end;	test;	end );DefConst ( 'k_StrMungeCRLFFunc, UR ( 'ERCore, 'StrMungeCRLF ) );	// func ( uniTxt ) - appends <CR> <LF> to txt (ALWAYS)DefConst ( 'k_SMungeAppendFunc, UR ( 'ERCore, 'SMungeAppend ) );	// func ( destUniTxt, appendUniTxt )DefConst ( 'k_Ensure2CRsFunc, UR ( 'ERCore, 'Ensure2TailCRs ) );	// func ( uniTxt ) - makes sure txt ends with 2 and only 2 <CR>s (unless "")DefConst ( 'k_StripHeadCRsFunc, UR ( 'ERCore, 'StripHeadCRs ) );	// func ( uniTxt ) - removes <CR>s at start of uniTxtDefConst ( 'k_StripTailCRsFunc, UR ( 'ERCore, 'StripTailCRs ) );	// func ( uniTxt ) - removes <CR>s from end of uniTxtif not K_BUILD_FLAG_MIMEPART2 then	DefConst ( 'k_UnwrappedLineFunc, UR ( 'ERCore, 'UnwrappedLine ) );		// func ( uniTxt, startPos )  -- returns new uniStrelse	DefConst ( 'k_UnwrappedLineFunc, func ( uniTxt, startPos )		begin		local suspectStr :=			call UR ( 'ERCore, 'UnwrappedLine ) with ( uniTxt, startPos );		local qpS := "=?iso-8859-1?Q?";		local qpF := "?=";		if not StrPos ( suspectStr, qpS, 0 ) then			return suspectStr;		local words := SplitString ( suspectStr );		local int i;		local s;		foreach i, s in words do			begin			s := TrimString(s);			if BeginsWith(s, qpS) and EndsWith(s, qpF) then				begin				s := SubStr ( s, 15, StrLen(s)-(15+2) );				local newSLen := call kUnquoteInPlaceFunc with (s);				s := SubStr(s, 0, newSLen );				words[i] := s;				end;			end;		local result := words[0];		for i := 1 to Length ( words ) - 1 do			result := result && words[i];		StrReplace ( result, " _ ", " ", nil );		StrReplace ( result, "_", " ", nil );		result;		end );DefConst ( 'k_EncTxAsBinHexFunc, func(msg)	begin	"More later. Stay tuned.";	end );DefConst ( 'k_ConvDateToMacFunc, func(newtMin)	begin	if not newtMin then		begin		if self.boxItem and boxItem._modTime then			newtMin := boxItem._modTime;		else			newtMin := Time();		end;	local real cDT := 60.0 * newtMin;	local int cHi := RIntToL ( Trunc ( cDT / 65536 ) );	local int cLo := RIntToL ( FMod  ( cDT , 65536 ) );		{		macHi: cHi,		macLo: cLo,		}	end );DefConst ( 'k_GuessUUSizeFunc, func(x)	begin	local eolChars := Ceiling(x/45.0) * 3;	local expSize := Ceiling ( (x * 4) / 3.0 );	eolChars + expSize;	end );DefConst ( 'k_TryClrVBOFunc, func ( obj )	begin	if IsVBO ( obj ) then		begin		try ClearVBOCache ( obj );		onexception |evt.ex| do nil;		end;	end );DefConst ( 'k_TryMakeBinStrFunc, func ( maxReqd )	begin	if maxReqd < 0 then maxReqd := 2;	local binObj;	local freeHeap := stats();	/***********************************	if freeHeap < maxReqd then		begin		gc();		freeHeap := stats();		end;	***********************************/	// LRT - 97/09/09 4:08 AM	// is this still a requirement???	// we'll try to use any size in RAM if we have a HUGE heap	//if maxReqd < 20480 AND freeHeap > maxReqd then	//   ===============	// LRT - 98/02/10 4:02 AM	// WAS:	//if freeHeap > ( maxReqd + 4096 ) AND	//( freeHeap > 98000 or maxReqd < 20480 ) then	// NEW:	if maxReqd < 40000 AND 	freeHeap > ( maxReqd + 4096 ) AND	( freeHeap > 98000 or maxReqd < 20480 ) then		begin		try binObj := MakeBinary ( maxReqd, 'binary );		onexception |evt.ex| do binObj := nil;		end;	binObj := if binObj then		begin		if kDebugOn then print ( " - " && maxReqd && "byte obj in heap" );		MakeBinary ( 2, 'string );		end;	else		begin		if kDebugOn then print ( " - " && maxReqd && "byte obj on a store" );		// LRT - 96/10/08 2:09 PM		//GetRoot().(kAppSymbol):GetDefaultOwnerStore():NewVBO ( 'string, maxReqd ); // 2 );		GetRoot().(kAppSymbol):GetDefaultOwnerStore():NewVBO ( 'string, 2 );		end;	// RKR LRT - 96/10/08 2:17 PM	//BinaryMunger ( binObj, 0, nil, k_EmptyString, 0, nil ); 	binObj;	end );if kDebugOn then DefConst ( 'k_NotifyLesFunc, func ( txt )	begin	print ( ":call k_NotifyLesFunc with (txt)" );	print ( txt );	local s := "\n\n(try to report what was happening just now)";	GetRoot():Notify ( kNotifyAlert, "TELL LES THAT:", txt & s );	end );else  DefConst ( 'k_NotifyLesFunc, func ( txt ) nil );DefConst ( 'k_WierdSrvrRespFunc, func ( ourTx, srvTx, what, state )	begin	if not StrFilled ( ourTx ) then ourTx := k_EmptyString;	// ""; // LRT - 97/01/13 1:33 PM	if not StrFilled ( srvTx ) then srvTx := k_EmptyString;	// ""; // LRT - 97/01/13 1:33 PM	local p1S := Clone ( ourTx );	try		StrReplace ( p1S, "\n", k_EmptyString, nil );		StrReplace ( p1S, "\u000A", k_EmptyString, nil);		local p2S := Clone ( srvTx );		StrReplace ( p2S, "\n", k_EmptyString, nil );		StrReplace ( p2S, "\u000A", k_EmptyString, nil);	onexception |evt.ex| do nil;	if kDebugOn then		begin		print ( ":call k_WierdSrvrRespFunc with (ourTx, srvTx)" );		write ( "ourTx: " );		print ( p1S );		write ( "srvTx: " );		print ( p2S );		write ( "what: " );		print ( what );		write ( "state: " );		print ( state );		end;	local s := LocObj ( "Unable to continue. Server error:\nIt said: ^1\n\nafter we sent: ^0 ", 'errors.serverWierd );	s := ParamStr ( s, [ p1S, p2S ] );	GetRoot():Notify ( kNotifyAlert, kAppName, s );	end );/*************************DefConst ( 'k_UniqueIDSearchProc, func ( a, b )	begin	// Exact match of message ID	(a.msgID and b.msgID and StrExactCompare(a.msgID, b.msgID) = 0)	or	// Exact match of message Unique ID	(a.UID and b.UID and StrExactCompare(a.UID, b.UID) = 0)	or	// (no subjects or Same Subjects)	//      AND	// (no Senders or Same Senders)	//      AND	// same Date	( ( (not (a.subj and b.subj)) or ( StrExactCompare(a.subj, b.subj) = 0 ) )	and	  (not (a.from and b.from) or ( StrExactCompare(a.from, b.from) = 0 ) )	and	  a.when  = b.when	)	end );*************************/DefConst ( 'k_TimeTo822Func, func ( when )	begin	local gmt := GetUserConfig ( 'location ).gmt;	local savings := GetUserConfig ( 'daylightsavings );	local theOffset := ( gmt + savings ) / 36;	local theOffsetStr := if theOffset < 0 then "-" else "+";	theOffset := abs(theOffset);	if theOffset < 1000 then theOffsetStr := theOffsetStr & "0";	theOffsetStr := theOffsetStr & theOffset;	local naZones := [ "P", "M", "C", "E", "A" ];	local gZ := 8 + (gmt / 3600);	if gZ > -1 and gZ < 5 then		theOffsetStr := theOffsetStr &&			$( & naZones[gZ] & (if savings = 0 then "S" else "D") & "T" & $);	local theCurrTime := Date ( when );	// LRT - 97/04/11 5:33 AM	// NEW:	local monthsA   := [ nil, "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ];	// LRT - 97/04/13 9:25 PM	// Sunday is dayOfWeek ZERO	// WAS:	//local weekdaysA := [ nil, "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun" ];	// NEW:	local weekdaysA := [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ];	local theTimeStr :=		   weekdaysA [ theCurrTime.dayOfWeek ] & ", "		&  LongDateStr ( when, (@66).numericDayStrSpec )		&& monthsA [ theCurrTime.month ]		&& LongDateStr ( when, (@66).numericYearStrSpec )		&& (if theCurrTime.hour   < 10 then "0") & theCurrTime.hour		&  $:		&  (if theCurrTime.minute < 10 then "0") & theCurrTime.minute		&& theOffsetStr;	// LRT - 97/04/11 5:33 AM	// WAS:	/*****************************************************************	local theTimeStr :=		   LongDateStr ( when, (@66).abbrDayOfWeekStrSpec ) & ", "		&  LongDateStr ( when, (@66).numericDayStrSpec )		&& LongDateStr ( when, (@66).abbrMonthStrSpec )		&& LongDateStr ( when, (@66).numericYearStrSpec )		&& (if theCurrTime.hour   < 10 then "0") & theCurrTime.hour		&  $:		&  (if theCurrTime.minute < 10 then "0") & theCurrTime.minute	//	&  $:	//	&  (if theCurrTime.second < 10 then "0") & theCurrTime.second		&& theOffsetStr;	*****************************************************************/	theTimeStr;	end );DefConst ( 'k_TimeFrom822Func, func(dateStr)	begin	if StrLen(dateStr) < 10 then		return 0;	// Fri, 28 Jun 1996 10:47:00 -0400 (EDT)	local dayNum  := 1;	local monNum  := 1;	local yearNum := 1904;	local hourNum := 0;	local mintNum := 0;	local gmtOff  := 0;	try 		local commaPos := StrPos ( dateStr, ",", 0 );		if commaPos <> nil then			begin			local spcPos := commaPos + 1;			while IsWhiteSpace(dateStr[spcPos]) and spcPos < StrLen(dateStr) do				begin				spcPos := spcPos + 1;				end;			dateStr := Substr(dateStr, spcPos, StrLen(dateStr) - spcPos);			end;		dayNum := RIntToL ( StringToNumber ( Substr(dateStr, 0, 2) ) );		if IsWhiteSpace ( dateStr[2] ) then			dateStr := Substr ( dateStr, 3, StrLen(dateStr) - 3 );		else			dateStr := Substr ( dateStr, 2, StrLen(dateStr) - 2 );		local monSym := Intern ( Substr ( dateStr, 0,3 ) );		local moNameF :=			{ jan:  1, feb:  2, mar:  3, apr:  4, may:  5, jun:  6,			  jul:  7, aug:  8, sep:  9, oct: 10, nov: 11, dec: 12, };		if moNameF.(monSym) then monNum := moNameF.(monSym);		local markPos := StrPos ( dateStr, " ", 0 );		// strip off the month name		if markPos then			dateStr := Substr ( dateStr, markPos + 1, StrLen(dateStr) - markPos - 1 );		markPos := StrPos ( dateStr, " ", 0 );		if markPos then			begin			local yearStr := Substr ( dateStr, 0, markPos );			yearNum := RIntToL ( StringToNumber(yearStr) );			if yearNum > 90 and yearNum < 100 then				yearNum := yearNum + 1900;			else if yearNum >= 0 and yearNum <= 90 then				yearNum := yearNum + 2000;			local endPos := StrPos ( dateStr, " ", markPos + 1 );			local timeS;			if endPos then				timeS := Substr ( dateStr, markPos + 1, endPos - markPos - 1 );			if endPos and timeS then				begin				markPos := StrPos ( timeS, ":", 0);				if markPos then					begin					hourNum := RIntToL ( StringToNumber(Substr(timeS, 0, markPos)) );					mintNum := RIntToL ( StringToNumber(Substr(timeS, markPos + 1, 2)) );					end;				markPos := StrPos ( dateStr, " ", endPos + 1 );				if markPos = nil then					markPos := StrLen(dateStr);				local gmtStr := Substr ( dateStr, endPos + 1, markPos - endPos - 1 );				if gmtStr then					try 						StrReplace ( gmtStr, "+", k_EmptyString, nil );						local gmtVal := StringToNumber(gmtStr);						if gmtVal <> nil then							gmtOff := RIntToL ( gmtVal );					onexception |evt.ex| do begin end;				end;			end;	onexception |evt.ex| do begin end;	local dateF := { month: monNum, date: dayNum, day: dayNum, year: yearNum,		hour: hourNum, minute: mintNum, second: 0 };	local theTime := TotalMinutes ( dateF );	if gmtVal then		begin		local userGMT := (GetUserConfig('location).gmt + GetUserConfig('daylightsavings)) / 36;		theTime := theTime + (userGMT - gmtOff) / 100 * 60;		end;	theTime;	end );// LRT - 97/04/15 8:00 AM// Since this conversion is now used in many places, it is// worth having as a const functionDefConst ( 'k_SpecialToUSAsciiFunc, func ( hasSpecials )	begin	local usAscii;	local convFunc := func ( str, newOff )		begin		usAscii := str;		nil;			// exit from "kWrapTxAsyncFunc"		end;	local bin := MakeBinary ( 512, 'binary );	call kWrapTxAsyncFunc with ( hasSpecials, bin,		0, 128, convFunc, NIL );	TrimString ( usAscii );		// remove trailing <CR>	end );DefConst ( 'k_822QuotesToOptsFunc, func ( addrTxt )	begin	// LRT - 97/04/22 1:49 AM	// Function to replace commas and quotes in received	// RFC-822 header text with special option characters	// which we can use to put them back later	local s := Clone ( addrTxt );	local inQuote;	local inParen;	local int i;	for i := 0 to StrLen(s) - 1 do		begin		if not inParen and s[i] = $" then			begin			if inQuote then inQuote := nil			else inQuote := true;			end;		else if not inQuote and s[i] = $( then			inParen := true;		else if inParen and s[i] = $) then			inParen := nil;		else if inQuote or inParen then			begin			// LRT - 97/06/03 2:01 AM			// WAS:			//if s[i] = $, then s[i] := $\E7; //$\B8;	// shift-opt-z			// NEW:			if s[i] = $, then s[i] := $\1B;			// <ESC>			else if s[i] = $\\ and s[i+1] = $" then				begin				//s[i] := $\20;				s[i+1] := $\A8;				end;			end;		end;	// will be done in "k_AddrFrom822Func"	//StrReplace ( s, "\u005C00A8", "\u005C0022", nil );	s;	end );DefConst ( 'k_StrTo822QuotesFunc,func(str)	begin	if not StrFilled(str) then return k_EmptyString;	try		// LRT - 97/04/15 8:41 AM		// user names with special chars need better translation		// than just stripping out non-ASCII		// WAS:		//str := StringFilter ( str, kStd7BitASCIIChars, 'passAll );		//TrimString ( str );		// NEW:		str := call k_SpecialToUSAsciiFunc with ( str );		local hasSpecials;		local i;		if StrPos ( str, "\u0022", 0 ) then			begin			StrReplace ( str, "\u0022", "\\\"", nil );	//  <"> to <\">			hasSpecials := true;			end;		else for i := 0 to StrLen(str) - 1 do			if not IsAlphaNumeric(str[i]) and str[i] <> $\20 then				hasSpecials := true;		if hasSpecials then			str := $\22 & str & $\22;		// surround with quotes	onexception |evt.ex| do nil;	str;	end );DefConst ( 'k_StrToAlphaNumOnlyFunc, func ( s )	begin	local r := k_EmptyString;	local i;	for i := 0 to StrLen(s)-1 do		if IsAlphaNumeric(s[i]) then r := r & s[i];	r;	end );DefConst ( 'k_ChrAsHexFunc, func ( num )	begin	local str;	local size := 2;	repeat 		str := "0123456789ABCDEF"[band(num, 0x0F)] & str;		num := num >> 4;		size := size - 1;	until size <= 0;	str;	end );DefConst ( 'k_StrToHexQuotedOSTypeFunc, func ( str )	begin	if not StrFilled(str) then str := "????";	local osType := SubStr(str,0,4) & "    ";	local i;	local s := $";	for i := 0 to 3 do		begin		s := s & call k_ChrAsHexFunc with ( ord( osType[i] ) );		end;	s & $";	end );DefConst ( 'k_HexQuotedOSTypeToStrFunc, func(s)	begin	local r := k_EmptyString;	s := s & "3F3F3F3F";	local i;	for i := 0 to 7 by 2 do		begin		local cord := Ord(s[i]);		if cord > 96 then cord := 10 + (cord - 97);		if cord > 64 then cord := 10 + (cord - 65);		else cord := cord - 48;		local v := cord * 16;		cord := Ord(s[i+1]);		if cord > 96 then cord := 10 + (cord - 97);		if cord > 64 then cord := 10 + (cord - 65);		else cord := cord - 48;		local v := v + cord;		r := r & Chr(v);		end;	r;	end );//		local owner := call k_OwnerIsTitzeFunc with ();DefConst ( 'k_OwnerIsTitzeFunc, func()	begin	local owner := ResolveEntryAlias ( userConfiguration.currentPersona );	if owner then owner := owner.name;	if owner then owner := owner.last;	owner := (owner and IsString(owner) and StrEqual(owner,"Titze") );	owner;	end );