DefConst ( 'kV_Server_HasData, func ( entry )	begin	local index, item;	local retVal := true;	if not entry.enRouteAccess or Length(entry.enRouteAccess) = 0 then		begin		retVal := nil;		end;	else foreach index, item in entry.enRouteAccess do		begin		if not item.enRouteMailPhone		or StrLen(item.enRouteMailPhone) < 1		then			retVal := nil;		end;	return retVal;	end	);DefConst ( 'kV_Server_GetPath, func ( entry, context )	begin	local thePath := [ pathExpr: 'enRouteAccess, 0 ];	local erTransport := GetVariable ( context, 'transport );	local serverKind := erTransport.appSymbol;	local newServer :=		{		enRouteServer:     serverKind,		enRouteServerName: nil,		enRouteMailPhone:  nil,		};	if not entry.enRouteAccess or Length(entry.enRouteAccess) = 0 then		begin		entry.enRouteAccess := Array ( 1, newServer );		thePath := [ pathExpr: 'enRouteAccess, 0 ];		return thePath;		end;	local index, item;	foreach index, item in entry.enRouteAccess do		begin		if item.enRouteServer = serverKind then			begin			thePath := [ pathExpr: 'enRouteAccess, index ];			return thePath;			end;		end;	// were other servers but not this kind so we add one	index := Length(entry.enRouteAccess);	AddArraySlot ( entry.enRouteAccess, newServer );	thePath := [ pathExpr: 'enRouteAccess, index ];	thePath;	end	);DefConst ( 'k_ConnectValidationDef,{server:	{	enRouteServer:		{		type: 'server,		inputProto:			{			_proto: newtFalseEntryView,			},		HasData: kV_Server_HasData,		GetPath: kV_Server_GetPath,		},	enRouteServerName:		{		type:       'text,		theText:	"Server Name",		inputProto:			{			_proto: newtLabelInputLine,			},		HasData: kV_Server_HasData,		GetPath: kV_Server_GetPath,		},	New_enRouteMailPhone:		{		type: 'number,		inputProto:			{			_proto: newtLabelPhoneInputLine,			},		HasData: kV_Server_HasData,		GetPath: kV_Server_GetPath,		},	enRouteMailPhone:		{		inputProto: GetLayout ( "Cv_serverInput" ),		type: 'text,		HasData: func ( entry )			begin			local index, item;			local retVal := true;			if not entry.enRouteAccess or Length(entry.enRouteAccess) = 0 then				begin				retVal := nil;				end;			else foreach index, item in entry.enRouteAccess do				begin				if not not item.enRouteMailPhone				or StrLen(item.enRouteMailPhone) < 1 then					retVal := nil;				end;			return retVal;			end,		GetPath: func ( entry, context )			begin			local thePath := [ pathExpr: 'enRouteAccess, 0 ];			local erTransport := GetVariable ( context, 'transport );			local serverKind := erTransport.appSymbol;			local newServer :=				{				enRouteServer:     serverKind,				enRouteServerName: nil,				enRouteMailPhone:  nil,				};			if not entry.enRouteAccess or Length(entry.enRouteAccess) = 0 then				begin				entry.enRouteAccess := Array ( 1, newServer );				thePath := [ pathExpr: 'enRouteAccess, 0 ];				return thePath;				end;			local index, item;			foreach index, item in entry.enRouteAccess do				begin				if item.enRouteServer = serverKind then					begin					thePath := [ pathExpr: 'enRouteAccess, index ];					return thePath;					end;				end;			// were other servers but not this kind so we add one			index := Length(entry.enRouteAccess);			AddArraySlot ( entry.enRouteAccess, newServer );			thePath := [ pathExpr: 'enRouteAccess, index ];			return thePath;			end,		},	},location:	{	enRouteMailPhone:		{		inputProto:	GetLayout ( "Cv_phoneInput" ),		type: 'number,		HasData: func ( entry )			begin			local retVal;			local phone;			if entry.enRouteAccess and entry.enRouteAccess[0]			and entry.enRouteAccess[0].enRouteMailPhone then				begin				local phone :=					if not IsInstance ( entry.enRouteAccess[0].enRouteMailPhone, 'string) then						begin						local dash := "-";						local t := SPrintObject ( entry.enRouteAccess[0].enRouteMailPhone );						if StrLen(t) = 7 then							StrMunger ( t, 3, 0, dash, 0, length(dash) );						t;						end;					else						entry.enRouteAccess[0].enRouteMailPhone;				// WAS:				// phone := call k_ConvertIntToPhoneFunc with ( entry.enRouteAccess[0].enRouteMailPhone );				retVal := entry.enRouteAccess[0].enRouteServer					and StrFilled(phone);				end;			retVal;			end,		GetPath: func ( entry, context )			begin			if not entry.enRouteAccess or length ( entry.enRouteAccess ) < 1 then				entry.enRouteAccess := [{}];			'[ pathExpr: enRouteAccess, 0 ];			end,		}	},owner:	{	email:		{		inputProto: GetLayout ( "Cv_emailInput" ),		type:		'text,		theText:	"EnRoute Acct",		GetPath: func ( entry, context )			begin			local path;			local adrSyms := GetVariable ( context, 'addressSymbols );			if entry.email and length(adrSyms) > 0 and IsInstance ( entry.email, adrSyms[0] ) then				return 'email;			else				begin				local index, addr;				foreach index, addr in entry.emailAddrs do					begin					if not addr.email then						path := [ pathExpr: 'emailAddrs, index, 'email ];					else if length(adrSyms) > 0 and IsInstance ( addr.email, adrSyms[0] ) then						return [ pathExpr: 'emailAddrs, index, 'email ];					end;				if not entry.email then					return 'email;				else if path then					return path;				else					begin					AddArraySlot ( entry.emailAddrs, {} );					return [ pathExpr: 'emailAddrs, length(entry.emailAddrs) - 1, 'email ]					end;				end;			end,		},	emailPassword:		{		inputProto:	newtLabelinputLine,		type:		'text,		theText:	"E-Mail Password",		GetPath: func ( entry, context )			begin			local path;			local adrSyms := GetVariable ( context, 'addressSymbols);			if entry.email and Length(adrSyms) > 0 and IsInstance ( entry.email, adrSyms[0] ) then				return 'emailPassword;			else				begin				local index, addr;				foreach index, addr in entry.emailAddrs do					if not addr.email then						path := [ pathExpr: 'emailAddrs, index, 'emailPassword ];					else if length(adrSyms) > 0 and IsInstance ( addr.email, adrSyms[0] ) then						return [ pathExpr: 'emailAddrs, index, 'emailPassword ];				if not entry.email then					return 'emailPassword;				else					return path;				end;			end,		},	},} );