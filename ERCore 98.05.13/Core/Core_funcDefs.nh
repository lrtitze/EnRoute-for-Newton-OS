DefConst ( 'k_EmptyString, "" );DefConst ( 'k_MakeEMailValidTestFunc, func ( anEmail )	begin	func(e)		begin		if (e.class = 'person or e.class = 'owner) then			begin			if e.email			and StrEqual ( e.email, anEmail ) then			//and ClassOf(e.email) = ClassOf(anEmail) then				return true;			else if IsArray ( e.emailAddrs ) then				begin				local m;				foreach m in e.emailAddrs do					begin					if m.email					and StrEqual ( m.email, anEmail ) then					//and ClassOf(m.email) = ClassOf(anEmail) then						return true;					end;				end;			end;		nil;		end;	end );DefConst ( 'k_RegEMailSystemFunc, func ( classSym, name, internet )	begin	local gEMS := GetGlobalVar ( 'EmailSystems );	if gEMS.emailText.(classSym) exists then		begin		return NIL;		// to indicate that it was already installed		end;	if not HasSlot ( gEMS, 'emailClasses ) or IsReadOnly(gEMS.emailClasses) then		begin		// we have to clone the arrays and frames to modify them!!		gEMS := Clone ( gEMS );		gEMS.(EnsureInternal('emailClasses)) := Clone ( gEMS.emailClasses );		gEMS.(EnsureInternal('emailText)) := Clone ( gEMS.emailText );		gEMS.(EnsureInternal('emailInternet)) := Clone ( gEMS.emailInternet );		DefGlobalVar ( 'EmailSystems, gEMS );		end;	local sym := EnsureInternal ( classSym );	AddArraySlot ( gEMS.emailClasses, sym );	gEMS.emailText.(sym)     := EnsureInternal ( name );	gEMS.emailInternet.(sym) := EnsureInternal ( internet );	TRUE;		// indicate that an install WAS PERFORMED	end );DefConst ( 'k_PullStrFromBinFunc, func ( binObj, stripCR )	begin	local s;	if Length(binObj) > 0 then		begin		s := ExtractCString ( binObj, 0 );		BinaryMunger ( binObj, 0, StrLen(s)+1, nil, 0, nil );		if stripCR then			begin			local v := StrLen(s)-1;			local x := CharPos ( s, $\0D, v );			// LRT - 97/01/13 1:29 PM			// Ryan suggests never passing NIL 4th parameter			// WAS:			// if x then StrMunger ( s, x, nil, nil, 0, nil )			// NEW:			if x then StrMunger ( s, x, nil, k_EmptyString, 0, nil )			end;		end;	s;	end	);DefConst ( 'k_AppendCStringFunc, func ( binObj, str )	begin	local objLen := Length(binObj);	local csLen := StrLen(str) + 1;	try		SetLength ( binObj, objLen + csLen );		StuffCString ( binObj, objLen, str );	onexception |evt.ex| do		begin		if kDebugOn then DefGlobalVar ( 'erAppendCString, CurrentException() );		end;	end	);/**********************************************************\	UNICODE STRING UTILS AS NATIVE FUNCS\**********************************************************/DefConst ( 'k_SMungeAppendFunc, func native (str,append)	begin	// LRT - 97/01/13 1:29 PM	// Ryan suggests never passing NIL 4th parameter	// WAS:	// StrMunger ( str, StrLen(str), nil, append, 0, nil );	// NEW:	StrMunger ( str, StrLen(str), nil,		if not append then k_EmptyString else append, 0, nil );	end );DefConst ( 'k_StrMungeCRLFFunc, func native (str)	begin	StrMunger ( str, StrLen(str), nil, "\u000D000A", 0, nil );	end );DefConst ( 'k_StripHeadCRsFunc, func native ( uniTxt )	begin	// LRT - 96/10/29 12:01 PM	// adding safety check	if not IsString(uniTxt) or not StrFilled(uniTxt) then return;	local e := StrLen(uniTxt);	if e = 1 then		begin		if uniTxt[0] = $\n then			StrMunger ( uniTxt, 0, 1, k_EmptyString, 0, nil );			// LRT - 97/01/13 1:29 PM			// Ryan suggests never passing NIL 4th parameter			// WAS:			// StrMunger ( uniTxt, 0, 1, nil, 0, nil );		return;		end;	local n;	if not e = 0 and uniTxt[n := 0] = $\n then		begin		StrMunger ( uniTxt, 0, if not (while uniTxt[n := n + 1] = $\n do if n = e-1 then begin n := e;break;end) then n,			k_EmptyString, 0, nil );			// LRT - 97/01/13 1:29 PM			// Ryan suggests never passing NIL 4th parameter			// WAS:			// nil, 0, nil );		end;	/**************** EQUIVALENT TO ******************\	local e := StrLen(uniTxt);	local n;	if not e = 0 and uniTxt[n := 0] = $\n then		begin		while uniTxt[n := n + 1] = $\n do			if n = e-1 then				begin				n := e;				break;				end;		StrMunger ( uniTxt, 0, n, nil, 0, nil );		end;	 ******************** OR ************************* 	if not StrLen(uniTxt) = 0 then		begin		local n := 0;		if uniTxt[n] = $\n then			begin			while uniTxt[n := n + 1] = $\n do nil;			StrMunger ( uniTxt, 0, n, nil, 0, nil );			end;		end;	\*************************************************/	end );DefConst ( 'k_StripTailCRsFunc, func native ( uniTxt )	begin	/**************** EQUIVALENT TO ******************\	local int n;	if uniTxt[n := StrLen(uniTxt)-1] = $\n then		begin		StrMunger ( uniTxt, if not (while uniTxt[n := n - 1] = $\n do nil) then n+1, nil, nil, 0, nil );		end;	\*************************************************/	// LRT - 96/10/29 12:01 PM	// adding safety check	if not IsString(uniTxt) or not StrFilled(uniTxt) then return;	local int n := StrLen(uniTxt) - 1;	if n < 0 then return;			// can't remove from nothing	if uniTxt[n] = $\n then		begin		if n > 0 then			begin			while uniTxt[n := n - 1] = $\n do  if n = 0 then begin n := -1; break; end;			end;		else			n := -1;		// LRT - 97/01/13 1:29 PM		// Ryan suggests never passing NIL 4th parameter		// WAS:		// StrMunger ( uniTxt, n+1, nil, nil, 0, nil );		// NEW:		StrMunger ( uniTxt, n+1, nil, k_EmptyString, 0, nil );		end;	end );DefConst ( 'k_Ensure2CRsFunc, func native ( uniTxt )	begin	// LRT - 96/10/29 12:01 PM	// adding safety check	if not IsString(uniTxt) or not StrFilled(uniTxt) then return;	local int n := StrLen(uniTxt) - 1;	if n < 0 then return;			// no need for 2 CRs at end of nothing!!	if uniTxt[n] = $\n then		begin		if n > 0 then			begin			if uniTxt[n - 1] = $\n and (n = 1 or not uniTxt[n-2] = $\n) then return;			while uniTxt[n := n - 1] = $\n do if n = 0 then begin n := -1; break; end;			end;		else			n := -1;		end;	if n < 0 then n := -1;	StrMunger ( uniTxt, n+1, nil,   "\n\n", 0, nil );	/***************** OLD WAY **************************\	while EndsWith ( uniTxt, "\n\n\n" ) do		StrMunger ( uniTxt, StrLen(uniTxt)-1, 1, nil, 0, nil );	while not EndsWith ( uniTxt, "\n\n" ) do		StrMunger ( uniTxt, 0x3FFFFFF, nil,			"\n",	0, nil );	\****************************************************/	end );DefConst ( 'k_UnwrappedLineFunc, func native ( txt, sPos )	begin	local max := StrLen(txt) - 1;	local eolPos := CharPos ( txt, $\n, sPos );	while eolPos and eolPos < max and IsWhiteSpace ( txt[eolPos+1] ) do		eolPos := CharPos ( txt, $\n, eolPos+1 );	if not eolPos then eolPos := StrLen(txt);	local rStr := SubStr ( txt, sPos, eolPos - sPos );	if StrLen(rStr) > 0 then		begin		local n := sPos;		while (n := CharPos ( txt, $\n, n+1 )) and n < eolPos do			rStr[ (n - sPos) ] := $\u0001;		if (n := StrPos(rStr,"\u00010001",0) ) then			rStr := SubStr ( rStr, 0, n );		StrReplace ( rStr, "\u0001", "", nil );		end;	TrimString(rStr);	end );DefConst ( 'k_StandardBin_CalcCRC, kCalcCRCFunc );/*************************************************************DefConst ( 'XX_k_StandardBin_CalcCRC, func native (binData, int start, int len)	begin	local array crcT := '[ 0,     4129,  8258,  12387, 16516, 20645, 24774, 28903, 33032, 37161, 41290, 45419, 49548, 53677, 57806, 61935, 4657,  528,   12915, 8786,  21173, 17044, 29431, 25302, 37689, 33560, 45947, 41818, 54205, 50076, 62463, 58334, 9314,  13379, 1056,  5121,  25830, 29895, 17572, 21637, 42346, 46411, 34088, 38153, 58862, 62927, 50604, 54669, 13907, 9842,  5649,  1584,  30423, 26358, 22165, 18100, 46939, 42874, 38681, 34616, 63455, 59390, 55197, 51132, 18628, 22757, 26758, 30887, 2112,  6241,  10242, 14371, 51660, 55789, 59790, 63919, 35144, 39273, 43274, 47403, 23285, 19156, 31415, 27286, 6769,  2640,  14899, 10770, 56317, 52188, 64447, 60318, 39801, 35672, 47931, 43802, 27814, 31879, 19684, 23749, 11298, 15363, 3168,  7233,  60846, 64911, 52716, 56781, 44330, 48395, 36200, 40265, 32407, 28342, 24277, 20212, 15891, 11826, 7761,  3696,  65439, 61374, 57309, 53244, 48923, 44858, 40793, 36728, 37256, 33193, 45514, 41451, 53516, 49453, 61774, 57711, 4224,  161,   12482, 8419,  20484, 16421, 28742, 24679, 33721, 37784, 41979, 46042, 49981, 54044, 58239, 62302, 689,   4752,  8947,  13010, 16949, 21012, 25207, 29270, 46570, 42443, 38312, 34185, 62830, 58703, 54572, 50445, 13538, 9411,  5280,  1153,  29798, 25671, 21540, 17413, 42971, 47098, 34713, 38840, 59231, 63358, 50973, 55100, 9939,  14066, 1681,  5808,  26199, 30326, 17941, 22068, 55628, 51565, 63758, 59695, 39368, 35305, 47498, 43435, 22596, 18533, 30726, 26663, 6336,  2273,  14466, 10403, 52093, 56156, 60223, 64286, 35833, 39896, 43963, 48026, 19061, 23124, 27191, 31254, 2801,  6864,  10931, 14994, 64814, 60687, 56684, 52557, 48554, 44427, 40424, 36297, 31782, 27655, 23652, 19525, 15522, 11395, 7392,  3265, 61215, 65342, 53085, 57212, 44955, 49082, 36825, 40952, 28183, 32310, 20053, 24180, 11923, 16050, 3793,  7920,];	local bin := binData;	local int stop := (start + len) - 1;	local int crcCC1 := 0;	local int i;	for i := start to stop do		begin		crcCC1 := BAnd (			BXor ( ( crcCC1 << 8 ), crcT [				BAnd (					BXor ( ( crcCC1 >> 8 ), ExtractByte(bin,i) ),					255) ] ),			65535 );		end;	return crcCC1;	end	);***************************************************************/DefConst ( 'k_StandardBin_CheckSum, func native (binData, int start, int len)	begin	local bin := binData;	local int stop := (start + len) - 1;	local int sum := 0;	local int i;	for i := start to stop do		begin		sum := BAnd ( sum + ExtractByte(bin,i), 0x00FF );		end;	sum;	end	);DefConst ( 'k_DataClassOfFunc, func ( item )	begin	local theClass := nil;	if item then		begin		if IsFrame(item) then			begin			if item.body then				begin				theClass := call k_DataClassOfFunc with (item.body);				if theClass = 'frame then					theClass := nil;				end;			if theClass = nil then				theClass := item.class;			if not theClass then				theClass := item.viewStationery;			end;		if theClass = nil then			theClass := ClassOf ( item );		end;	theClass;	end	);DefConst ( 'k_GetTargetFromEntryFunc, func ( it )	begin	if not it then return;	local realItem := if it.body then		it.body;	else		it;	if it.needsResolve then		begin		local fmt := GetCurrentFormat(it);		if fmt then			realItem := fmt:ResolveBody ( it );		if not realItem then			GetRoot():Notify ( kNotifyAlert, GetRoot().ioBox.title,				LocObj ( "This item cannot be routed; the original has been removed or deleted.", 'errors.noRouteBody ) );		end;	realItem;	end	);// SortByClass ( theArray, theSymbol, sortSlot );DefConst ( 'k_SortByClassFunc, func ( theArray, theSyms, sortSlot )	begin	local classes := theSyms;	if not IsArray ( classes ) then classes := [ theSyms ];	local path := sortSlot;	StableSort ( theArray, '|<|, func(Arg1)		begin		local Local1, Local2;		Local2 := if path then			Arg1.(path);		else			Arg1;		Local1 := LSearch ( classes, ClassOf(Local2), 0, '|=|, nil );		if Local1 then			Local1;		else			10000;		end );	end	);DefConst ( 'k_TorontoMungePhoneFunc, func ( phone, country )	begin	local ph := GetRoot():MungePhone ( phone, country );	ph := TrimString(ph);	local currAreaCode := GetUserConfig ( 'currentAreaCode );	currAreaCode := if currAreaCode then currAreaCode else "";	if not StrFilled(currAreaCode) then		begin		local parsedPhone := ParsePhone ( userConfiguration.phone );		if parsedPhone and parsedPhone.areacode then			currAreaCode := parsedPhone.areacode;		else			begin			parsedPhone := ParsePhone ( userConfiguration.homePhone );			if parsedPhone and parsedPhone.areacode then				currAreaCode := parsedPhone.areacode;			else				begin				parsedPhone := ParsePhone ( userConfiguration.faxPhone );				if parsedPhone and parsedPhone.areacode then					currAreaCode := parsedPhone.areacode;				end;			end;		end;	currAreaCode := StringFilter(currAreaCode, "0123456789", 'passAll);	if StrEqual ( currAreaCode, "416" )	and BeginsWith ( ph, "1 905 " ) then		ph := SubStr (ph,2,999);	else if StrEqual ( currAreaCode, "905" )	and BeginsWith ( ph, "1 416 " ) then		ph := SubStr (ph,2,999);	return ph;	/*****************	if IsRichString(phone) then return clone("");	local currLocation := GetUserConfig ( 'location );	local currAreaCode := GetUserConfig ( 'currentAreaCode );	currAreaCode := if currAreaCode then currAreaCode else "";	if not StrFilled(currAreaCode) then		begin		local parsedPhone := ParsePhone ( userConfiguration.phone );		if parsedPhone and parsedPhone.areacode then			currAreaCode := parsedPhone.areacode;		else			begin			parsedPhone := ParsePhone ( userConfiguration.homePhone );			if parsedPhone and parsedPhone.areacode then				currAreaCode := parsedPhone.areacode;			else				begin				parsedPhone := ParsePhone ( userConfiguration.faxPhone );				if parsedPhone and parsedPhone.areacode then					currAreaCode := parsedPhone.areacode;				end;			end;		end;	currAreaCode := StringFilter(currAreaCode, "0123456789", 'passAll);	SetUserConfig ( 'currentAreaCode, currAreaCode );	if GetUserConfig ( 'currentCountry ) = 'Canada	and StrEqual ( currAreaCode, "416" )	or StrEqual ( currAreaCode, "905" ) then		begin		local phNum := Clone ( phone );		local phNum := StringFilter ( phNum, "0123456789", 'passAll);		if BeginsWith ( phNum, "1905")		or BeginsWith ( phNum, "905") then			SetUserConfig ( 'currentAreaCode, "905" );		else if BeginsWith ( phNum, "1416")		or BeginsWith ( phNum, "416") then			SetUserConfig ( 'currentAreaCode, "416" );		end;	local mPhone := GetRoot():MungePhone ( phone, country );	SetUserConfig ( 'currentAreaCode, currAreaCode );	mPhone;	****************/	end	);