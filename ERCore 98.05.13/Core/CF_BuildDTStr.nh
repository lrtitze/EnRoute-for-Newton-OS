// build an RFC822 time string// call as://		the timeStr :=  "Date:" && :Build_DTStr ( Time() );/***********************************************************************\     5.  DATE AND TIME SPECIFICATION     5.1.  SYNTAX     date-time   =  [ day "," ] date time        ; dd mm yy                                                 ;  hh:mm:ss zzz     day         =  "Mon"  / "Tue" /  "Wed"  / "Thu"                 /  "Fri"  / "Sat" /  "Sun"     date        =  1*2DIGIT month 2DIGIT        ; day month year                                                 ;  e.g. 20 Jun 82     month       =  "Jan"  /  "Feb" /  "Mar"  /  "Apr"                 /  "May"  /  "Jun" /  "Jul"  /  "Aug"                 /  "Sep"  /  "Oct" /  "Nov"  /  "Dec"     time        =  hour zone                    ; ANSI and Military     hour        =  2DIGIT ":" 2DIGIT [":" 2DIGIT]                                                 ; 00:00:00 - 23:59:59     zone        =  "UT"  / "GMT"                ; Universal Time                                                 ; North American : UT                 /  "EST" / "EDT"                ;  Eastern:  - 5/ - 4                 /  "CST" / "CDT"                ;  Central:  - 6/ - 5                 /  "MST" / "MDT"                ;  Mountain: - 7/ - 6                 /  "PST" / "PDT"                ;  Pacific:  - 8/ - 7                 /  1ALPHA                       ; Military: Z = UT;                                                 ;  A:-1; (J not used)                                                 ;  M:-12; N:+1; Y:+12                 / ( ("+" / "-") 4DIGIT )        ; Local differential                                                 ;  hours+min. (HHMM)     5.2.  SEMANTICS          If included, day-of-week must be the day implied by the date     specification.          Time zone may be indicated in several ways.  "UT" is Univer-     sal  Time  (formerly called "Greenwich Mean Time"); "GMT" is per-     mitted as a reference to Universal Time.  The  military  standard     uses  a  single  character for each zone.  "Z" is Universal Time.     "A" indicates one hour earlier, and "M" indicates 12  hours  ear-     lier;  "N"  is  one  hour  later, and "Y" is 12 hours later.  The     letter "J" is not used.  The other remaining two forms are  taken     from ANSI standard X3.51-1975.  One allows explicit indication of     the amount of offset from UT; the other uses  common  3-character     strings for indicating time zones in North America.\***********************************************************************/DefConst ( 'k_BuildDTStrFunc, func ( when )	begin	local gmt := GetUserConfig ( 'location ).gmt;	local savings := GetUserConfig ( 'daylightsavings );	local theOffset := ( gmt + savings ) / 36;	local theOffsetStr := if theOffset < 0 then "-" else "+";	theOffset := abs(theOffset);	if theOffset < 1000 then theOffsetStr := theOffsetStr & "0";	theOffsetStr := theOffsetStr & theOffset;	local naZones := [ "P", "M", "C", "E", "A" ];	local gZ := 8 + (gmt / 3600);	if gZ > -1 and gZ < 5 then		theOffsetStr := theOffsetStr &&			$( & naZones[gZ] & (if savings = 0 then "S" else "D") & "T" & $);	local theCurrTime := Date ( when );	// LRT - 97/04/11 5:33 AM	// NEW:	local monthsA   := [ nil, "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ];	local weekdaysA := [ nil, "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun" ];	local theTimeStr :=		   weekdaysA [ theCurrTime.dayOfWeek ] & ", "		&  LongDateStr ( when, (@66).numericDayStrSpec )		&& monthsA [ theCurrTime.month ]		&& LongDateStr ( when, (@66).numericYearStrSpec )		&& (if theCurrTime.hour   < 10 then "0") & theCurrTime.hour		&  $:		&  (if theCurrTime.minute < 10 then "0") & theCurrTime.minute		&& theOffsetStr;	// LRT - 97/04/11 5:33 AM	// WAS:	/*****************************************************************	local theTimeStr :=		   LongDateStr ( when, (@66).abbrDayOfWeekStrSpec ) & ", "		&  LongDateStr ( when, (@66).numericDayStrSpec )		&& LongDateStr ( when, (@66).abbrMonthStrSpec )		&& LongDateStr ( when, (@66).numericYearStrSpec )		&& (if theCurrTime.hour   < 10 then "0") & theCurrTime.hour		&  $:		&  (if theCurrTime.minute < 10 then "0") & theCurrTime.minute	//	&  $:	//	&  (if theCurrTime.second < 10 then "0") & theCurrTime.second		&& theOffsetStr;	*****************************************************************/	theTimeStr;	end );